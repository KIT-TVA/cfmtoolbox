{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The CFM Toolbox is a plugin-based framework for working with cardinality-based feature models. The framework ships with a set of core plugins, but can also easily be extended with third-party and custom plugins.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Easily extensible: Designed to be easily extensible with third-party and custom plugins</li> <li>Core plugins: Core plugins provide essential functionality for working with CFMs</li> <li>Command-line interface: The included CLI allows for easy automation of tasks</li> <li>Cross-platform: Written in Python, the toolbox runs on all major operating systems</li> <li>FeatureIDE import: XML-based FeatureIDE feature models can easily be imported</li> <li>UVL import and export: Universal Variability Language files are supported out of the box</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The CFM Toolbox, it's dependencies, and core plugins can easily be installed from the Python Package Index (PyPI) using the following command:</p> <pre><code>pip3 install cfmtoolbox\n</code></pre>"},{"location":"getting-started/#running-the-cfm-toolbox","title":"Running the CFM Toolbox","text":"<p>After the installation, the CFM Toolbox can be run from the command line using the following command:</p> <pre><code>python3 -m cfmtoolbox\n</code></pre>"},{"location":"getting-started/#usage-examples","title":"Usage examples","text":"<p>Making use of the toolbox's core plugins and your shell's capabilities, you can already perform a variety of tasks without any third-party dependencies.</p>"},{"location":"getting-started/#sampling-a-cfm","title":"Sampling a CFM","text":"<p>The following command demonstrates sampling a minimal UVL-based CFM using a random sampling strategy:</p> <pre><code>echo \"features\\n\\tminimalism\" &gt; example.uvl\npython3 -m cfmtoolbox --import example.uvl random-sampling\n</code></pre>"},{"location":"getting-started/#storing-command-outputs","title":"Storing command outputs","text":"<p>By making use your of shell's redirection capabilities, you can easily store the output in a file:</p> <pre><code>echo \"features\\n\\tminimalism\" &gt; example.uvl\npython3 -m cfmtoolbox --import example.uvl random-sampling &gt; sampling.json\n</code></pre>"},{"location":"getting-started/#applying-a-timeout","title":"Applying a timeout","text":"<p>Some commands may take a long time to execute. Using your shell's built-in <code>timeout</code> command, you can apply a timeout to the sampling process like so:</p> <pre><code>echo \"features\\n\\tminimalism\" &gt; example.uvl\ntimeout 5 python3 -m cfmtoolbox --import example.uvl random-sampling\n</code></pre>"},{"location":"getting-started/#converting-between-formats","title":"Converting between formats","text":"<p>The CFM Toolbox can also be used to convert between different model formats, such as UVL and JSON:</p> <pre><code>echo \"features\\n\\tminimalism\" &gt; example.uvl\npython3 -m cfmtoolbox --import example.uvl --export example.json convert\n</code></pre>"},{"location":"getting-started/#installing-additional-plugins","title":"Installing additional plugins","text":"<p>The CFM Toolbox will automatically detect and load plugins that are installed in the same Python environment. This makes installing plugins as easy as running <code>pip3 install</code> with the desired plugin's name.</p> <p>For example, to install the <code>cfmtoolbox-hello-world</code> plugin, you can run:</p> <pre><code>pip3 install cfmtoolbox-hello-world\n</code></pre> <p>After installing this particular plugin, a new <code>hello-world</code> command will be available in the toolbox. You can see all available commands by running the following command:</p> <pre><code>python3 -m cfmtoolbox --help\n</code></pre>"},{"location":"framework/","title":"Architecture","text":"<p>The CFM Toolbox is a plugin-based framework for working with cardinality-based feature models and consists of three main components:</p> <ul> <li>Shared models for representing feature models</li> <li>A plugin system for extending the toolbox with new functionality</li> <li>A command-line interface for interacting with the toolbox</li> </ul> <p>All three components are glued together by the <code>CFMToolbox</code> class, which is instantiated when the <code>cfmtoolbox</code> Python module is run as a script (i.e., its <code>__main__.py</code> file is run via <code>python3 -m cfmtoolbox</code>).</p>"},{"location":"framework/#models","title":"Models","text":"<p>The core models included in the toolbox are shared between the framework, core plugins, and third-party plugins. Since they are used to exchange data between first-party and third-party code, they are meant to be kept stable.</p> <p>Warning</p> <p>Introducing breaking changes to the models will break plugins, so keep their interfaces lean.</p> <p>The toolbox's models live in the <code>cfmtoolbox.models</code> module and are mostly implemented as Python dataclasses. Take a look at the models documentation to learn more about the available models, their fields, and methods.</p>"},{"location":"framework/#plugin-system","title":"Plugin system","text":"<p>The toolbox's plugin system discovers plugins based on Python package metadata and the Entry points specification. This allows us to discover and load core plugins and third-party plugins installed in the same environment as the toolbox in the same way.</p> <p>Plugins can be used to extend the toolbox with new functionality. This can be done by using Python decorators provided by the toolbox. The following decorators can be used to register new functionality with the toolbox:</p>"},{"location":"framework/#importers","title":"Importers","text":"<p>The <code>importer</code> decorator is used to register new importers with the toolbox. Importers are used to import feature models from different formats into the toolbox's internal representation.</p> <p>Generally, importers handle exactly one file format, receive a file's contents as bytes, and return a CFM model instance. The framework chooses the importer to use based on the file extension of the file being imported. For example, the signature of on <code>.uvl</code> file importer would look like this:</p> <pre><code>@app.importer(\".uvl\")\ndef import_uvl(file_contents: bytes) -&gt; CFM: ...\n</code></pre> <p>To learn more please refer to the writing plugins guide.</p>"},{"location":"framework/#commands","title":"Commands","text":"<p>The <code>command</code> decorator is used to register new commands with the toolbox. A command can be used to process feature models which have been imported into the toolbox.</p> <p>Generally, commands receive a CFM model instance, process the instance, and return the processed instance. Returning the processed instance enables users to export the processed instance and chain commands via shell scripting. The name of commands is derived from the function name. For example, the following signature would register a command named <code>my-command</code>:</p> <pre><code>@app.command()\ndef my_command(cfm: CFM) -&gt; CFM: ...\n</code></pre> <p>Note that commands can also take additional arguments, which can be passed to the command via the toolbox's command-line interface. Extra arguments must use Python type hints to be automatically picked up by the framework. Here is an example signature of a command that takes an optional integer argument with a default value of <code>10</code>:</p> <pre><code>@app.command()\ndef my_command(cfm: CFM, my_argument: int = 10) -&gt; CFM: ...\n</code></pre> <p>To learn more please refer to the writing plugins guide.</p>"},{"location":"framework/#exporters","title":"Exporters","text":"<p>The <code>exporter</code> decorator is used to register new exporters with the toolbox. Exporters are used to export feature models from the toolbox's internal representation to different formats.</p> <p>Generally, exporters handle exactly one file format, receive a CFM model instance and return the model's contents as bytes. The framework chooses the exporter to use based on the file extension of the file being exported. For example, the signature of on <code>.uvl</code> file exporter would look like this:</p> <pre><code>@app.exporter(\".uvl\")\ndef export_uvl(cfm: CFM) -&gt; bytes: ...\n</code></pre> <p>To learn more please refer to the writing plugins guide.</p>"},{"location":"framework/#command-line-interface","title":"Command Line Interface","text":"<p>The toolbox's CLI can be used to import models into the toolbox, process them with commands, and export them. All commands of the toolbox are implemented via the plugin system.</p> <p>The CLI itself is powered by typer, a powerful and type-safe CLI library. One key feature of <code>typer</code> is, that it can automatically generate a CLI based on Python type hints. This is precicesly how the <code>@app.command()</code> decorator works under the hood. Furthermore, this allows CFM Toolbox commands to make use of all <code>typer</code> features, such as descriptions for commands and arguments, autocompletion, and more.</p>"},{"location":"framework/contributing/","title":"Contributing","text":"<p>Below you'll find some useful commands to get started if you want to contribute to the framework itself. Note that we use poetry for project and dependency management.</p>"},{"location":"framework/contributing/#project-setup","title":"Project setup","text":"<ol> <li>Install poetry</li> <li>Install project dependencies by running <code>poetry install</code></li> </ol>"},{"location":"framework/contributing/#running-the-cfmtoolbox","title":"Running the cfmtoolbox","text":"<p>After installing the project and its dependencies, you can run the development version of the CFM Toolbox using the following command: </p> <pre><code>poetry run cfmtoolbox\n</code></pre>"},{"location":"framework/contributing/#formatting-linting","title":"Formatting linting","text":"<p>We use <code>ruff</code> for code formatting and linting, and <code>mypy</code> for static type checking.</p> <p>You can format your code by running</p> <pre><code>poetry run ruff format .\n</code></pre> <p>To check for linting errors, run the following command:</p> <pre><code>poetry run ruff check .\n</code></pre> <p>For static type checking, run the following command:</p> <pre><code>poetry run mypy .\n</code></pre> <p>To automatically check the formatting, linting, and static type checking on every commit, you can install the pre-commit hooks:</p> <pre><code>poetry run pre-commit install\n</code></pre>"},{"location":"framework/contributing/#testing","title":"Testing","text":"<p>We use <code>pytest</code> for testing. To run the tests, use the following command:</p> <pre><code>poetry run pytest\n</code></pre> <p>A test coverage report will automatically be generated, displayed in the terminal, and exported as an interactive HTML report in the <code>htmlcov</code> directory.</p>"},{"location":"framework/contributing/#previewing-the-documentation","title":"Previewing the documentation","text":"<p>We use <code>mkdocs</code> to generate the documentation from markdown files and to deploy it to GitHub Pages. While working on the documentation, you can preview it locally by running the following command:</p> <pre><code>poetry run mkdocs serve\n</code></pre>"},{"location":"framework/models/","title":"Models","text":""},{"location":"framework/models/#cfmtoolbox.models.CFM","title":"CFM  <code>dataclass</code>","text":"<pre><code>CFM(root: Feature, constraints: list[Constraint])\n</code></pre> <p>Dataclass representing a feature model.</p> <p>Attributes:</p> <ul> <li> <code>constraints</code>               (<code>list[Constraint]</code>)           \u2013            <p>List of constraints in the feature model.</p> </li> <li> <code>features</code>               (<code>list[Feature]</code>)           \u2013            <p>Dynamically computed list of all features in the feature model.</p> </li> <li> <code>is_unbound</code>               (<code>bool</code>)           \u2013            <p>Check if the feature model is unbound.</p> </li> <li> <code>root</code>               (<code>Feature</code>)           \u2013            <p>Root feature of the feature model.</p> </li> </ul>"},{"location":"framework/models/#cfmtoolbox.models.CFM.constraints","title":"constraints  <code>instance-attribute</code>","text":"<pre><code>constraints: list[Constraint]\n</code></pre> <p>List of constraints in the feature model.</p>"},{"location":"framework/models/#cfmtoolbox.models.CFM.features","title":"features  <code>property</code>","text":"<pre><code>features: list[Feature]\n</code></pre> <p>Dynamically computed list of all features in the feature model.</p>"},{"location":"framework/models/#cfmtoolbox.models.CFM.is_unbound","title":"is_unbound  <code>property</code>","text":"<pre><code>is_unbound: bool\n</code></pre> <p>Check if the feature model is unbound.</p>"},{"location":"framework/models/#cfmtoolbox.models.CFM.root","title":"root  <code>instance-attribute</code>","text":"<pre><code>root: Feature\n</code></pre> <p>Root feature of the feature model.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature","title":"Feature  <code>dataclass</code>","text":"<pre><code>Feature(\n    name: str,\n    instance_cardinality: Cardinality,\n    group_type_cardinality: Cardinality,\n    group_instance_cardinality: Cardinality,\n    parent: Feature | None,\n    children: list[Feature],\n)\n</code></pre> <p>Dataclass representing a feature in a feature model.</p> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>list[Feature]</code>)           \u2013            <p>List of child features.</p> </li> <li> <code>group_instance_cardinality</code>               (<code>Cardinality</code>)           \u2013            <p>Group instance cardinality of the feature.</p> </li> <li> <code>group_type_cardinality</code>               (<code>Cardinality</code>)           \u2013            <p>Group type cardinality of the feature.</p> </li> <li> <code>instance_cardinality</code>               (<code>Cardinality</code>)           \u2013            <p>Instance cardinality of the feature</p> </li> <li> <code>is_required</code>               (<code>bool</code>)           \u2013            <p>Check if the feature is required.</p> </li> <li> <code>is_unbound</code>               (<code>bool</code>)           \u2013            <p>Check if the feature is unbound.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Globally unique name of the feature.</p> </li> <li> <code>parent</code>               (<code>Feature | None</code>)           \u2013            <p>Parent feature. None if root feature.</p> </li> </ul>"},{"location":"framework/models/#cfmtoolbox.models.Feature.children","title":"children  <code>instance-attribute</code>","text":"<pre><code>children: list[Feature]\n</code></pre> <p>List of child features.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.group_instance_cardinality","title":"group_instance_cardinality  <code>instance-attribute</code>","text":"<pre><code>group_instance_cardinality: Cardinality\n</code></pre> <p>Group instance cardinality of the feature.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.group_type_cardinality","title":"group_type_cardinality  <code>instance-attribute</code>","text":"<pre><code>group_type_cardinality: Cardinality\n</code></pre> <p>Group type cardinality of the feature.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.instance_cardinality","title":"instance_cardinality  <code>instance-attribute</code>","text":"<pre><code>instance_cardinality: Cardinality\n</code></pre> <p>Instance cardinality of the feature</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.is_required","title":"is_required  <code>property</code>","text":"<pre><code>is_required: bool\n</code></pre> <p>Check if the feature is required.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.is_unbound","title":"is_unbound  <code>property</code>","text":"<pre><code>is_unbound: bool\n</code></pre> <p>Check if the feature is unbound.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Globally unique name of the feature.</p>"},{"location":"framework/models/#cfmtoolbox.models.Feature.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Feature | None\n</code></pre> <p>Parent feature. None if root feature.</p>"},{"location":"framework/models/#cfmtoolbox.models.Cardinality","title":"Cardinality  <code>dataclass</code>","text":"<pre><code>Cardinality(intervals: list[Interval])\n</code></pre> <p>Dataclass representing a cardinality.</p> <p>Methods:</p> <ul> <li> <code>is_valid_cardinality</code>             \u2013              <p>Check if a value is a valid cardinality for the given intervals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>intervals</code>               (<code>list[Interval]</code>)           \u2013            <p>Ordered list of cardinality intervals.</p> </li> </ul>"},{"location":"framework/models/#cfmtoolbox.models.Cardinality.intervals","title":"intervals  <code>instance-attribute</code>","text":"<pre><code>intervals: list[Interval]\n</code></pre> <p>Ordered list of cardinality intervals.</p>"},{"location":"framework/models/#cfmtoolbox.models.Cardinality.is_valid_cardinality","title":"is_valid_cardinality","text":"<pre><code>is_valid_cardinality(value: int) -&gt; bool\n</code></pre> <p>Check if a value is a valid cardinality for the given intervals.</p> Source code in <code>cfmtoolbox/models.py</code> <pre><code>def is_valid_cardinality(self, value: int) -&gt; bool:\n    \"\"\"Check if a value is a valid cardinality for the given intervals.\"\"\"\n\n    for interval in self.intervals:\n        if (interval.lower &lt;= value) and (\n            interval.upper is None or interval.upper &gt;= value\n        ):\n            return True\n    return False\n</code></pre>"},{"location":"framework/models/#cfmtoolbox.models.Interval","title":"Interval  <code>dataclass</code>","text":"<pre><code>Interval(lower: int, upper: int | None)\n</code></pre> <p>Dataclass representing a cardinality interval.</p> <p>Attributes:</p> <ul> <li> <code>lower</code>               (<code>int</code>)           \u2013            <p>Lower bound of the interval.</p> </li> <li> <code>upper</code>               (<code>int | None</code>)           \u2013            <p>Upper bound of the interval. None if unbounded.</p> </li> </ul>"},{"location":"framework/models/#cfmtoolbox.models.Interval.lower","title":"lower  <code>instance-attribute</code>","text":"<pre><code>lower: int\n</code></pre> <p>Lower bound of the interval.</p>"},{"location":"framework/models/#cfmtoolbox.models.Interval.upper","title":"upper  <code>instance-attribute</code>","text":"<pre><code>upper: int | None\n</code></pre> <p>Upper bound of the interval. None if unbounded.</p>"},{"location":"framework/models/#cfmtoolbox.models.ConfigurationNode","title":"ConfigurationNode  <code>dataclass</code>","text":"<pre><code>ConfigurationNode(\n    value: str, children: list[ConfigurationNode]\n)\n</code></pre> <p>Dataclass representing configuration of a CFM feature.</p> <p>Methods:</p> <ul> <li> <code>validate</code>             \u2013              <p>Validate the feature node against the feature model.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>children</code>               (<code>list[ConfigurationNode]</code>)           \u2013            <p>List of child feature nodes.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>Value of the feature node.</p> </li> </ul>"},{"location":"framework/models/#cfmtoolbox.models.ConfigurationNode.children","title":"children  <code>instance-attribute</code>","text":"<pre><code>children: list[ConfigurationNode]\n</code></pre> <p>List of child feature nodes.</p>"},{"location":"framework/models/#cfmtoolbox.models.ConfigurationNode.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>Value of the feature node.</p>"},{"location":"framework/models/#cfmtoolbox.models.ConfigurationNode.validate","title":"validate","text":"<pre><code>validate(cfm: CFM) -&gt; bool\n</code></pre> <p>Validate the feature node against the feature model.</p> Source code in <code>cfmtoolbox/models.py</code> <pre><code>def validate(self, cfm: CFM) -&gt; bool:\n    \"\"\"Validate the feature node against the feature model.\"\"\"\n\n    # Check if root feature is valid\n    if cfm.root.name != self.value.split(\"#\")[0]:\n        return False\n\n    if not self.validate_children(cfm.root):\n        return False\n\n    return self.validate_constraints(cfm)\n</code></pre>"},{"location":"framework/writing-plugins/","title":"Writing Plugins","text":"<p>CFM Toolbox plugins are Python packages with entry point metadata, installed in the same environment as the toolbox, and discovered and loaded at runtime. Each Python package can contain multiple plugins, which can be used to extend the toolbox with new functionality.</p> <p>Generally, there are three types of plugins: importers, commands, and exporters. We highly recommend using <code>python-poetry</code> to manage your plugin's dependencies and packaging. Below you'll find guides on how to write each type of plugin using <code>python-poetry</code>.</p>"},{"location":"framework/writing-plugins/#importers","title":"Importers","text":"<ol> <li>Start by running <code>poetry new cfmtoolbox-example-importer</code> to create a new Python project</li> <li>Now switch to the project directory by running <code>cd cfmtoolbox-example-importer</code></li> <li>Next, run <code>poetry add cfmtoolbox</code> to add the framework as a dependency</li> <li> <p>To create a minimal valid importer, add the following code to your <code>cfmtoolbox_example_importer/__init__.py</code> file:</p> <pre><code>from cfmtoolbox import app, CFM, Feature, Cardinality\n\n@app.importer(\".example\")\ndef import_example(file_contents: bytes) -&gt; CFM:\n    # TODO: parse the `file_contents` and construct a real CFM\n\n    return CFM(\n        root=Feature(\n            name=\"sandwich\",\n            instance_cardinality=Cardinality(intervals=[]),\n            group_type_cardinality=Cardinality(intervals=[]),\n            group_instance_cardinality=Cardinality(intervals=[]),\n            parent=None,\n            children=[]\n        ),\n        constraints=[],\n    )\n</code></pre> </li> <li> <p>To enable the CFM Toolbox to discover and automatically load your plugin, add the following to your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cfmtoolbox.plugins\"]\nexample-importer = \"cfmtoolbox_example_importer\"\n</code></pre> </li> </ol> <p>That's it! As soon as you install your plugin in the same environment as the CFM Toolbox, it will be automatically discovered and loaded. This plugin would allow the CFM Toolbox to import feature models from a <code>.example</code> file format.</p>"},{"location":"framework/writing-plugins/#commands","title":"Commands","text":"<ol> <li>Start by running <code>poetry new cfmtoolbox-example-command</code> to create a new Python project</li> <li>Now switch to the project directory by running <code>cd cfmtoolbox-example-command</code></li> <li>Next, run <code>poetry add cfmtoolbox</code> to add the framework as a dependency</li> <li> <p>To create a minimal valid command, add the following code to your <code>cfmtoolbox_example_command/__init__.py</code> file:</p> <pre><code>from cfmtoolbox import app, CFM\n\n@app.command()\ndef example_command(cfm: CFM) -&gt; CFM:\n    print(f\"Nice CFM! It even has {len(cfm.constraints)} constraints!\")\n    return cfm\n</code></pre> </li> <li> <p>To enable the CFM Toolbox to discover and automatically load your plugin, add the following to your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cfmtoolbox.plugins\"]\nexample-command = \"cfmtoolbox_example_command\"\n</code></pre> </li> </ol> <p>That's it! As soon as you install your plugin in the same environment as the CFM Toolbox, it will be automatically discovered and loaded. This plugin would add a new <code>example-command</code> command to the CFM Toolbox, which would print the number of constraints in the CFM and return the CFM unchanged.</p>"},{"location":"framework/writing-plugins/#exporters","title":"Exporters","text":"<ol> <li>Start by running <code>poetry new cfmtoolbox-summary-exporter</code> to create a new Python project</li> <li>Now switch to the project directory by running <code>cd cfmtoolbox-summary-exporter</code></li> <li>Next, run <code>poetry add cfmtoolbox</code> to add the framework as a dependency</li> <li> <p>To create a minimal valid exporter, add the following code to your <code>cfmtoolbox_summary_exporter/__init__.py</code> file:</p> <pre><code>from cfmtoolbox import app, CFM\n\n@app.exporter(\".summary\")\ndef export_example(cfm: CFM) -&gt; bytes:\n    contents = f\"This CFM has {len(cfm.features)} features\"\n    return contents.encode(\"utf-8\")\n</code></pre> </li> <li> <p>To enable the CFM Toolbox to discover and automatically load your plugin, add the following to your <code>pyproject.toml</code> file:</p> <pre><code>[project.entry-points.\"cfmtoolbox.plugins\"]\nsummary-exporter = \"cfmtoolbox_summary_exporter\"\n</code></pre> </li> </ol> <p>That's it! As soon as you install your plugin in the same environment as the CFM Toolbox, it will be automatically discovered and loaded. This plugin would allow the CFM Toolbox to export feature models to a <code>.summary</code> file format, which would report the number of features in the CFM.</p>"},{"location":"plugins/","title":"Plugin Overview","text":"<p>Plugins are the primary way to extend the functionality of the CFM Toolbox.  They are designed to be modular and can be used to add support for new import and export formats, as well as new commands.</p>"},{"location":"plugins/#core-plugins","title":"Core Plugins","text":"<p>The CFM Toolbox ships with a set of core plugins that provide a variety of essential functionalities such as the import and export of UVL files.</p> <p>Keep browsing the documentation to learn more about the core plugins and how to use them.</p>"},{"location":"plugins/big-m/","title":"Big M","text":"<p>The Big-M plugin allows to replace infinite upper bounds by finite ones calculated with the Big-M method. The safe global upper bound is calculated by multiplying the upper bounds of all feature instance cardinalities along all branches from root to all leaf nodes and choosing the maximum value.</p>"},{"location":"plugins/big-m/#usage","title":"Usage","text":"<p>Import a cfm, apply the big-m method and export it:</p> <pre><code>python3 -m cfmtoolbox --import unbound.uvl --export bound.uvl apply-big-m\n</code></pre>"},{"location":"plugins/conversion/","title":"Conversion","text":"<p>The conversion plugin adds a <code>convert</code> command to the toolbox, which can be used to convert feature models between different formats. The supported formats depend on the installed plugins.</p>"},{"location":"plugins/conversion/#usage","title":"Usage","text":"<p>To convert an XML-based FeatureIDE feature model to the UVL format, use the following command:</p> <pre><code>python3 -m cfmtoolbox --import model.xml --export model.uvl convert\n</code></pre>"},{"location":"plugins/conversion/#usage-example","title":"Usage example","text":"<p>Create a basic FeatureIDE feature model file named <code>sandwich.xml</code> with the following content:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;featureModel&gt;\n    &lt;struct&gt;\n        &lt;feature abstract=\"true\" mandatory=\"true\" name=\"Sandwich\"/&gt;\n    &lt;/struct&gt;\n&lt;/featureModel&gt;\n</code></pre> <p>Convert the feature model to the UVL format:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.xml --export sandwich.uvl convert\n</code></pre>"},{"location":"plugins/conversion/#limitations","title":"Limitations","text":"<p>Currently, the toolbox determines the importer and exporter plugin to use solely based on the file extensions of the input and output files. In case multiple formats use the same file extension, the toolbox will still only use the first plugin supporting the file extension. This may be improved in the future.</p>"},{"location":"plugins/debugging/","title":"Debugging","text":"<p>The debugging plugin adds a <code>debug</code> command to the toolbox, which can be used to print the internal CFM model in a compact and readable way.</p>"},{"location":"plugins/debugging/#usage","title":"Usage","text":"<p>As long as a CFM model is returned in the used plugin in question, the debugging plugin can print the crucial information (Features, parents, children, cardinalities and constraints) for debug purposes by using the following command:</p> <pre><code>python3 -m cfmtoolbox --import model.uvl debug\n</code></pre>"},{"location":"plugins/debugging/#usage-example","title":"Usage example","text":"<p>Create a basic CFM model in any supported format, for example <code>sandwich.uvl</code>:</p> <pre><code>features\n    Sandwich\n</code></pre> <p>Then in order to import the UVL file to the CFM model, use the following command:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.uvl debug\n</code></pre>"},{"location":"plugins/featureide-import/","title":"FeatureIDE Import","text":"<p>The FeatureIDE import plugin enables the import of FeatureIDE feature models into the CFM Toolbox. FeatureIDE is a popular feature modeling tool that supports the creation and manipulation of feature models using a graphical interface.</p> <p>The FeatureIDE import plugin is a core plugin that comes pre-installed with the CFM Toolbox. Files with the <code>.xml</code> extension are automatically considered a FeatureIDE feature model and can be imported into the CFM Toolbox.</p>"},{"location":"plugins/featureide-import/#usage-example","title":"Usage example","text":"<p>Create a basic FeatureIDE feature model file named <code>sandwich.xml</code> with the following content:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;featureModel&gt;\n    &lt;struct&gt;\n        &lt;feature abstract=\"true\" mandatory=\"true\" name=\"Sandwich\"/&gt;\n    &lt;/struct&gt;\n&lt;/featureModel&gt;\n</code></pre> <p>Import the feature model into the CFM Toolbox and show some basic information about it:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.xml debug\n</code></pre>"},{"location":"plugins/featureide-import/#limitation","title":"Limitation","text":"<p>The current version of the FeatureIDE import plugin does not support the import of complex constraints containing conjunctions, disjunctions, or equations. It supports <code>implications</code> between two features and direct negations such as <code>A =&gt; B</code> and <code>not A =&gt; not not B</code>. If the imported file contains unsupported constraints, those will be omitted and printed to the terminal (stderr).</p>"},{"location":"plugins/json-export/","title":"JSON Export","text":"<p>The JSON export plugin enables the export of CFM models to JSON files. The JSON files created by this plugin represent a serialized version of the internal data structures used by the CFM Toolbox. JSON model files created this way can be imported back into the CFM Toolbox using the JSON import plugin.</p>"},{"location":"plugins/json-export/#usage-example","title":"Usage example","text":"<p>Create a basic CFM model in any supported format, for example <code>sandwich.uvl</code>:</p> <pre><code>features\n    Sandwich\n</code></pre> <p>Then, export the model to a JSON file named <code>sandwich.json</code> using the <code>convert</code> command, which will make use of the JSON export plugin:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.uvl --export sandwich.json convert\n</code></pre>"},{"location":"plugins/json-import/","title":"JSON Import","text":"<p>The JSON import plugin enables the import of JSON files created with the JSON export plugin. Both plugins serve as reference import and export plugins for the CFM Toolbox but are also used internally for testing. The JSON files handled by these plugins represent a serialized version of the internal data structures used by the CFM Toolbox.</p>"},{"location":"plugins/json-import/#usage-example","title":"Usage example","text":"<p>Create a JSON file named <code>sandwich.json</code> containing a basic CFM:</p> <pre><code>{\n  \"root\": {\n    \"name\": \"Sandwich\",\n    \"instance_cardinality\": {\n      \"intervals\": [\n        {\n          \"lower\": 1,\n          \"upper\": 1\n        }\n      ]\n    },\n    \"group_type_cardinality\": {\n      \"intervals\": []\n    },\n    \"group_instance_cardinality\": {\n      \"intervals\": []\n    },\n    \"children\": []\n  },\n  \"constraints\": []\n}\n</code></pre> <p>Then, import the model into the CFM Toolbox and show some basic information about it:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.json debug\n</code></pre>"},{"location":"plugins/one-wise-sampling/","title":"One Wise Sampling","text":"<p>The One Wise Sampling plugin allows one wise sampling for cardinality-based feature models. It generates a non-minimal set of random valid configurations that cover the model one wise under boundary interior coverage and instance set coverage and outputs them into the console.</p> <p>The One Wise Sampling plugin requires the model to be bound which means no infinite upper bounds as instance cardinalities are allowed. In case of an unbound model, you can use other plugins like the Big M plugin to replace infinte upper bounds with finite ones.</p>"},{"location":"plugins/one-wise-sampling/#usage","title":"Usage","text":"<p>Import a cfm and generate a one wise sample set for it:</p> <pre><code>python3 -m cfmtoolbox --import example.uvl one-wise-sampling\n</code></pre> <p>In case of an unbound model, transform the model first with e.g. the Big M plugin.</p> <pre><code>python3 -m cfmtoolbox --import unbound.uvl --export bound.uvl apply-big-m\npython3 -m cfmtoolbox --import bound.uvl one-wise-sampling \n</code></pre> <p>Because the sampling algorithm uses non-determinism, it is recommended to limit the runtime of the command with a timeout of e.g. <code>5</code> seconds.</p> <pre><code>timeout 5 python3 -m cfmtoolbox --import example.uvl one-wise-sampling\n</code></pre> <p>To store the sampling in a <code>.json</code> file, shell redirection can be used, as shown in the following example:</p> <pre><code>python3 -m cfmtoolbox --import example.uvl one-wise-sampling &gt; sampling.json\n</code></pre>"},{"location":"plugins/random-sampling/","title":"Random Sampling","text":"<p>The Random Sampling plugin allows random sampling for cardinality-based feature models. It generates a custom number of random valid configurations and outputs them into the console.</p> <p>The Random Sampling plugin requires the model to be bound which means no infinite upper bounds as instance cardinalities are allowed. In case of an unbound model, you can use other plugins like the Big M plugin to replace infinte upper bounds with finite ones.</p>"},{"location":"plugins/random-sampling/#usage","title":"Usage","text":"<p>Import a cfm and generate 5 random samples for it: The <code>--num-samples</code> parameter defaults to <code>1</code> if not specified.</p> <pre><code>python3 -m cfmtoolbox --import example.uvl random-sampling --num-samples 5\n</code></pre> <p>In case of an unbound model, transform the model first with e.g. the Big M plugin.</p> <pre><code>python3 -m cfmtoolbox --import unbound.uvl --export bound.uvl apply-big-m\npython3 -m cfmtoolbox --import bound.uvl random-sampling \n</code></pre> <p>Because the sampling algorithm uses non-determinism, it is recommended to limit the runtime of the command with a timeout of e.g. <code>5</code> seconds.</p> <pre><code>timeout 5 python3 -m cfmtoolbox --import example.uvl random-sampling\n</code></pre> <p>To store the sampling in a <code>.json</code> file, shell redirection can be used, as shown in the following example:</p> <pre><code>python3 -m cfmtoolbox --import example.uvl random-sampling &gt; sampling.json\n</code></pre>"},{"location":"plugins/uvl-export/","title":"UVL Export","text":"<p>The UVL export plugin enables the export of CFM models to UVL files. Universal-Variability-Language is community-driven and aims to create a unified language for Variability Models.</p>"},{"location":"plugins/uvl-export/#usage-example","title":"Usage example","text":"<p>Create a basic CFM model in any supported format, for example <code>sandwich.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;featureModel&gt;\n    &lt;struct&gt;\n        &lt;feature abstract=\"true\" mandatory=\"true\" name=\"Sandwich\"/&gt;\n    &lt;/struct&gt;\n&lt;/featureModel&gt;\n</code></pre> <p>Then, export the model to a UVL file named <code>sandwich.uvl</code> using the <code>convert</code> command, which will use the UVL export plugin:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.xml --export sandwich.uvl convert\n</code></pre>"},{"location":"plugins/uvl-export/#limitation","title":"Limitation","text":"<p>There is currently a loss of information during the export due to the UVL format not being able to have group type cardinalities and group instance cardinalities simultaneously. The following example illustrates this ambiguity. By having a <code>CheeseMix</code> with a group type cardinality of <code>[1..3]</code> and a group instance cardinality of <code>[3..3]</code> it is not always clear with of the two is meant, since both cardinalities impact the children.</p> <p>The following list summarized the cardinalities and how it is exported:</p> <ul> <li>Group type cardinality <code>[1..1]</code>: <code>alt</code></li> <li>Group type cardinality <code>[1..n]</code>: <code>or</code></li> <li>Group type cardinality <code>[0..n]</code> and group instance cardinality <code>[1..n]</code>: <code>[1..n]</code></li> <li>Group type cardinality <code>[n..n]</code>: <code>[n]</code></li> </ul> <p>Further, compounded cardinalities like <code>[0..2], [4..5]</code> are not supported by UVL and thus also not in the UVL export plugin. </p> <p>The constraints are exported in a specific way, for example the constraint <code>A =&gt; B</code> with the cardinalities <code>c(A) = [0..2]</code> and <code>c(B) = [1..1]</code> are exported as:</p> <pre><code>constraints\n    ((A &gt;= 0) &amp; (A &lt;= 2)) =&gt; (B = 1)\n</code></pre> <p>Currently, only the bare minimum needed for exporting our internal model is implemented. If additional UVL \"include\" statements are required, they must be added manually. The following shows the currently generated UVL \"include\" statements:</p> <pre><code>include\n    Arithmetic.feature-cardinality\n    Boolean.group-cardinality\n</code></pre>"},{"location":"plugins/uvl-import/","title":"UVL Import","text":"<p>The UVL import plugin enables the import of UVL files to CFM model. Universal-Variability-Language is community-driven and aims to create a unified language for Variability Models.</p>"},{"location":"plugins/uvl-import/#usage-example","title":"Usage example","text":"<p>Create an uvl file named <code>sandwich.uvl</code> containing a basic CFM:</p> <pre><code>features\n    Sandwich cardinality [1]\n</code></pre> <p>Import the model into the CFM Toolbox and show some basic information about it:</p> <pre><code>python3 -m cfmtoolbox --import sandwich.uvl debug\n</code></pre>"},{"location":"plugins/uvl-import/#limitation","title":"Limitation","text":"<ul> <li>UVL only supports two types of cardinalities: feature_cardinality and group_cardinality.   On the other hand CFM has three types of cardinalities, because the group_instance_cardinality is added.   The given group_cardinality is equal to the group_type_cardinality, even though some of the groups have a textual   representation instead of a numeric one (e.g. or) they can be converted.   The group_instance_cardinality has to be implied by the given type and internal structure of the model.</li> <li>Additional attributes supplied in UVL are not supported by CFM, so they will be ignored.</li> <li>UVL has the capability to have more than one group as children for a feature, but CFM only allows children from the   same type.   This problem is solved by creating indexed subfeatures, which have the specific children and will be part of a parent,   that has very general cardinalities.   With that the model can be imported without any problems, although you will have some information loss.</li> </ul> <pre><code>features\n    Sandwich\n        alternative\n            Bread\n            Brioche\n        or\n            Sauce\n            Cheese\n</code></pre>"}]}